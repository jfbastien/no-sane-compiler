<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>No sane compiler would optimize atomics</title>

                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/black.css">

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/zenburn.css">

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">

<section>
  <section>
    <h1>No Sane Compiler Would Optimize Atomics</h1>
    <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
  </section>
  <section>
    <strong><code class="c++" style="font-size: 400%">false</code></strong>
    <aside class="notes">
      <p>Compilers do optimize atomics, memory accesses around atomics, and utilize architecture-specific knowledge. My hobby is to encourage compilers to do more of this, programmers to rely on it, and hardware vendors to give us new atomic toys to optimize with. Oh, and standardize yet more close-to-the-metal concurrency and parallelism tools.</p>
      <p>But, you say, surely volatile always means volatile, there’s nothing wrong with my benign races, nothing could even go wrong with non-temporal accesses, and who needs 6 memory orderings anyways‽ I’m glad you asked, let me tell you about my hobby…</p>
    </aside>
  </section>
  <section>
    <h1>Disclaimer</h1>
    <aside class="notes">Peek under the hood. Prefer higher-level primitives (parallelism TS, mutex, etc).</aside>
  </section>
</section>

<section>
  <section><h1>Quick review</h1></section>
  <section>
    <p>C++11 added</p>
    <ul>
      <li class="fragment">A memory model</li>
      <li class="fragment">Threads</li>
      <li class="fragment">Classes to communicate between threads</li>
    </ul>
    <p class="fragment">Threads didn't exist before C++11</p>
  </section>
  <section>
    <h1>Sequential Consistency</h1>
    <p class="fragment">Naïve model: memory accesses are simply interleaved</p>
    <p class="fragment">Hardware doesn't work that way</p>
    <p class="fragment">Overly restrictive</p>
    <aside class="notes">Limits compiler + HW reordering / optimizations; access granularity; want to reason about atomic code regions</aside>
  </section>
  <section>
    <h1>SC-DRF</h1>
    <p class="fragment">Data race:</p>
    <ul>
      <li class="fragment">Two accesses to the same <em>memory location</em> by different threads are <em>not ordered</em></li>
      <li class="fragment">At least one of them stores to the memory location</li>
      <li class="fragment">At least one of them is not a synchronization action</li>
    </ul>
    <p class="fragment">Data races are UB</p>
    <aside class="notes">You should use address sanitizer</aside>
  </section>
  <section>
    <h1>Memory locations</h1>
    <p class="fragment">Either an object of <em>scalar type</em> or a maximal
        sequence of adjacent bit-fields all having non-zero width.</p>
    <p class="fragment">Arithmetic types, enumeration types, pointer types,
      pointer to member types, <code class="c++">std::nullptr_t</code>, and
      cv-qualified versions of these types are collectively called <em>scalar
      types</em>.
    </p>
    <aside class="notes">Also, address-freedom</aside>
  </section>
  <section>
    <h1>Ordering memory locations</h1>
    <p class="fragment">Two memory operations are ordered if they cannot occur simultaneously</p>
    <aside class="notes">That sounds simple!</aside>
  </section>
  <section>
    <h1>Ordering memory locations</h1>
    <p class="fragment">An evaluation A <em>happens before</em> an evaluation B if:
      <ul class="fragment">
        <li>A is <em>sequenced before</em> B, or</li>
        <li>A <em>inter-thread happens before</em> B</li>
      </ul>
    </p>
    <aside class="notes">More precisely...</aside>
  </section>
  <section>
    <h1>Sequenced before</h1>
    <p>An asymmetric, transitive, pair-wise relation between evaluations
      executed by a single thread, which induces a partial order among those
      evaluations. Given any two evaluations A and B, if A is <em>sequenced
      before</em> B, then the execution of A shall precede the execution of
      B. If A is not <em>sequenced before</em> B and B is not
      <em>sequenced before</em> A, then A and B are <em>unsequenced</em>.
    </p>
  </section>
  <section>
    <h1>Inter-thread happens before</h1>
    <ul>
      <li>A <em>synchronizes with</em> B, or</li>
      <li>A is <em>dependency-ordered before</em> B, or</li>
      <li>for some evaluation X
        <ul>
          <li>A <em>synchronizes with</em> X and X is <em>sequenced before</em> B, or</li>
          <li>A is <em>sequenced before</em> X and X <em>inter-thread happens before</em> B, or</li>
          <li>A <em>inter-thread happens before</em> X and X <em>inter-thread happens before</em> B.</li>
        </ul>
    </ul>
  </section>
  <section>
    <h1>Synchronizes with</h1>
    <p>An atomic operation A that performs a release operation on an atomic
      object M <em>synchronizes with</em> an atomic operation B that performs an
      acquire operation on M and takes its value from any side effect in the
      release sequence headed by A.
    </p>
  </section>
  <section>
    <h1>Dependency-ordered before</h1>
    <ul>
      <li>A performs a release operation on an atomic object M, and, in another
        thread, B performs a consume operation on M and reads a value written by
        any side effect in the release sequence headed by A, or</li>
      <li>for some evaluation X, A is <em>dependency-ordered before</em> X and X carries a dependency to B.</li>
    </ul>
    <p>[ Note: The relation “is dependency-ordered before” is analogous to
      “synchronizes with”, but uses release/consume in place of
      release/acquire. — end note ]
    </p>
  </section>
  <section>
    <h1>Synchronization operation</h1>
    <ul>
      <li class="fragment">On one or more memory locations: consume operation,
        an acquire operation, a release operation, or both an acquire and
        release operation.</li>
      <li class="fragment">Without an associated memory location: acquire fence,
        release fence, or both an acquire and release fence.</li>
    </ul>
    <aside class="notes">Also: relaxed atomic operations are not synchronization operations; atomic read-modify-write operations have special characteristics.</aside>
  </section>
  <section>
    <h1>[intro.multithread]</h1>
    <p class="fragment">1.10 Multi-threaded executions and data races</p>
    <aside class="notes">Also defines: thread of execution, forward-progress, etc.</aside>
  </section>
  <section>
    <h1>Thread support</h1>
    <ul>
      <li class="fragment"><code class="c++">std::thread</code></li>
      <li class="fragment"><code class="c++">std::mutex</code></li>
      <li class="fragment"><code class="c++">std::shared_mutex</code></li>
      <li class="fragment"><code class="c++">std::condition_variable</code></li>
      <li class="fragment"><code class="c++">std::future</code></li>
    </ul>
    <aside class="notes">I'll ignore these for the rest of the presentation.</aside>
  </section>
  <section>
    <h1>Atomic operations</h1>
    <p class="fragment"><strong>Atomic</strong>: indivisible with respect to all other atomic accesses to that object</p>
    <aside class="notes">No tearing, no duplication, no elision.</aside>
  </section>
  <section>
    <h1>Memory order</h1>
    <ul>
      <li class="fragment"><code class="c++">relaxed</code></li>
      <li class="fragment"><code class="c++">consume</code></li>
      <li class="fragment"><code class="c++">acquire</code></li>
      <li class="fragment"><code class="c++">release</code></li>
      <li class="fragment"><code class="c++">acq_rel</code></li>
      <li class="fragment"><code class="c++">seq_cst</code></li>
    </ul>
    <aside class="notes">Used as constants passed to atomic operations. You can use a runtime variable, but your life will be sad. Actually a lattice.</aside>
  </section>
  <section>
    <h1>Atomic</h1>
    <ul>
      <li class="fragment"><code class="c++">template&lt;class T&gt; struct atomic;</code></li>
      <li class="fragment"><code class="c++">template&lt;&gt; struct atomic&lt;integral&gt;;</code></li>
      <li class="fragment"><code class="c++">template&lt;class T&gt; struct atomic&lt;T*&gt;;</code></li>
    </ul>
    <aside class="notes">All atomics operations are on atomic objects. Lifetime of memory locations, exclusively atomic or not. Holds a representation of T (alignment, etc).</aside>
  </section>
  <section>
    <h1>Atomic&lt;T&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">load</code></li>
      <li class="fragment"><code class="c++">store</code></li>
      <li class="fragment"><code class="c++">exchange</code></li>
      <li class="fragment"><code class="c++">compare_exchange_{weak,strong}</code></li>
      <li class="fragment"><code class="c++">is_lock_free</code></li>
    </ul>
    <aside class="notes">Must be trivially copyable; can be structs, but watch out for padding bits! All have atomic ordering (except lock free).</aside>
  </section>
  <section>
    <h1>Atomic&lt;integral&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">fetch_add</code></li>
      <li class="fragment"><code class="c++">fetch_sub</code></li>
      <li class="fragment"><code class="c++">fetch_and</code></li>
      <li class="fragment"><code class="c++">fetch_or</code></li>
      <li class="fragment"><code class="c++">fetch_xor</code></li>
    </ul>
    <aside class="notes">Some shorthands (without ordering) and coercions; integers are two's complement (no UB!).</aside>
  </section>
  <section>
    <h1>Atomic&lt;T*&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">fetch_add</code></li>
      <li class="fragment"><code class="c++">fetch_sub</code></li>
    </ul>
  </section>
  <section>
    <h1>Fences</h1>
    <ul>
      <li class="fragment"><code class="c++">atomic_thread_fence</code></li>
      <li class="fragment"><code class="c++">atomic_signal_fence</code></li>
    </ul>
    <aside class="notes">Only really needed with relaxed. Signal fence is basically a compiler barrier.</aside>
  </section>
  <section>
    <h1>Lock-freedom</h1>
    <p class="fragment">Guaranteed for <code class="c++">std::atomic_flag</code></p>
    <p class="fragment">Roughtly: is there a compare-exchange for this size?</p>
    <p class="fragment">This is what I'm focusing on.</p>
    <aside class="notes">Why a runtime value? If it's not lock-free, you probably want to use a coarse-grained lock (unless you're lazy and want the implementation's locks).</aside>
  </section>
</section>

<section>
  <section>
    <h1>We have our tools!</h1>
    <p class="fragment">Why is the language set up this way?</p>
    <p class="fragment">Provide an abstraction for relevant hardware platforms.</p>
  </section>
  <section>
    <h1>x86-64</h1>
    <table style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">LOCK XCHG</code></td></tr>
      <tr><td>non-<code class="c++">seq_cst</code> fence</td><td><code class="x86asm"># free!</code></td></tr>
      <tr><td><code class="c++">seq_cst</code> fence</td><td><code class="x86asm">MFENCE</code></td></tr>
    </table>
  </section>
</section>

<section>
  <section>
    <h1><em>as-if</em></h1>
    <p class="fragment"><strong>more atomic</strong>: don’t violate forward progress</p>
    <p class="fragment"><strong>less atomic</strong>: don’t add non-benign race which weren’t already present</p>
  </section>
  <section>
    <p><h2>Put another way</h2></p>
    <p>correct programs must work under all executions an implementation is allowed to create</p>
    <aside class="notes">
      <p>Keep in mind: compilers optimize code that compiler developers see and think are worth optimizing. We’re not trying to trip you!</p>
    </aside>
  </section>
</section>

<section>
  <section><h2>Simple example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
void inc(std::atomic&lt;int&gt; *y) {
  *y += 1;
}
std::atomic&lt;int&gt; x;
void two() {
  inc(&x);
  inc(&x);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void two() {
  x += 2;
}
  </code></pre>
    <aside class="notes"><p>Adds atomicity but cannot hinder forward progress: correct.</p></aside>
  </section>
  <section><h2>Similar example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void inc(int val) {
  x += 1;
  x += val;
}
  </code></pre>
  <pre class="fragment"><code class="x86asm" data-noescape>
_Z3inci:
  lock incl x(%rip)
  lock addl %edi, x(%rip)
  </code></pre>
  <aside class="notes"><p>Not going to win a Turing award with this: `inc r/m` versus `add r/m, r`; both with lock prefix; inc doesn’t set carry (sometimes partial flag stall); both 3 bytes; one less register; check out Agner for μops / latency, lock prefix makes this moot. Maybe the compiler would know better after all?</p></aside>
  </section>
  <section><h2>Opportunities through inlining</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  x-&gt;compare_exchange_strong(expected, desired); // Inlined.
  return expected == desired;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  return x-&gt;compare_exchange_strong(expected, desired);
}
  </code></pre>
  <aside class="notes"><p>Generic code ends up with interesting cases such as these. bool is usually a flag… but returning it depends on ABI!</p></aside>
  </section>
  <section>
    <h2>A tricky one</h2>
    <p class="fragment">Works for any memory order but <code class="c++">release</code> and <code class="c++">acq_rel</code></p>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  T expected = desired;
  return x-&gt;compare_exchange_strong(expected, desired
    std::memory_order_seq_cst, std::memory_order_relaxed);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  return x-&gt;load(std::memory_order_seq_cst) == desired; // †
}
  </code></pre>
    <p class="fragment"><small>† compiler: mark transformed load as <em>release sequence</em> <sup>‡</sup></small></p>
    <p class="fragment"><small>‡ as defined in section 1.10 of the C++ standard</small></p>
  </section>
  <section>
    <h2>Stronger, faster</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  T z = x-&gt;load();
  x-&gt;store(y);
  return z;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  return x-&gt;exchange(y);
}
  </code></pre>
    <h2 class="fragment">better?</h2>
    <aside class="notes"><p>May not always pay off: architectures with weaker memory models may benefit from having write-after-read operations to the same location instead of having an atomic exchange.</p></aside>
  </section>
  <section>
    <h2>Moar!</h2>
    <p class="fragment">Inlining and constant propagation</p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(~(T)0)</code> → <code class="c++">atomic&lt;T&gt;::load()</code></p>
    <p class="fragment">Same for <code class="c++">fetch_or(0)</code> and <code class="c++">fetch_xor(0)</code></p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(0)</code> → <code class="c++">atomic&lt;T&gt;::store(0)</code></p>
  </section>
  <section>
    <h2>Takeaway</h2>
    <p class="fragment">If simple things are hard…</p>
    <p class="fragment">…is your inline assembly correct?</p>
    <p class="fragment">…will it remain correct?</p>
    <p class="fragment">Do you trust your compiler?</p>
    <aside class="notes"><p>Sorry to say, you’re already trusting your compiler (or deluding yourself).</p></aside>
  </section>
  <section>
    <p>What if the compiler emits suboptimal code?</p>
    <h2 class="fragment">File a bug!</h2>
  </section>
</section>

<section>
  <section>
    <h1>Sequence lock</h1>
    <ul>
      <li class="fragment">Get ticket number</li>
      <li class="fragment">Get the data</li>
      <li class="fragment">Check the ticket again
        <ul>
          <li>If odd: write was happening</li>
          <li>If different: write occurred</li>
          <li>If same: no write occurred, data is good</li>
        </ul>
      </li>
      <li class="fragment">If data isn’t good: try again</li>
    </ul>
    <aside class="notes"><p>Read-mostly; don’t starve writers.</p></aside>
  </section>
  <section>
    <pre><code class="c++" data-noescape>
std::tuple&lt;T, T&gt; reader() {
  T d1, d2; unsigned seq0, seq1;
  do {
    seq0 = seq.load(std::memory_order_acquire);
    d1 = data1.load(std::memory_order_relaxed);
    d2 = data2.load(std::memory_order_relaxed);
    <mark>std::atomic_thread_fence(std::memory_order_acquire);</mark>
    <mark>seq1 = seq.load(std::memory_order_relaxed);</mark>
  } while (seq0 != seq1 || seq0 &amp; 1);
  return {d1, d2};
}
    </code></pre>
    <pre><code class="c++" data-noescape>
void writer(T d1, T d2) {
  unsigned seq0 = seq.load(std::memory_order_relaxed);
  seq.store(seq0 + 1, std::memory_order_relaxed);
  data1.store(d1, std::memory_order_release);
  data2.store(d2, std::memory_order_release);
  seq.store(seq0 + 2, std::memory_order_release);
}
    </code></pre>
    <aside class="notes"><p>Relaxed can be reordered with each other; fence is heavy on some architectures; acquire over-constrains (prevents motion into critical section); not intuitive.</p></aside>
  </section>
  <section>
    <p>We <em>really</em> want a release store</p>
    <p class="fragment">(there is no release store)</p>
  </section>
  <section>
    <h2>Read-don’t-modify-write</h2>
    <pre class="fragment"><code class="c++" data-noescape>
T d1, d2;
unsigned seq0, seq1;
do {
  seq0 = seq.load(std::memory_order_acquire);
  d1 = data1.load(std::memory_order_relaxed);
  d2 = data2.load(std::memory_order_relaxed);
  <mark>seq1 = seq.fetch_add(0, std::memory_order_release);</mark>
} while (seq0 != seq1 || seq0 &amp; 1);
    </code></pre>
    <aside class="notes"><p>Better for some architectures; can move reads into critical section.</p></aside>
  </section>
  <section>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x200a76(%rip),%edx        # seq
 mov    0x200a74(%rip),%eax        # data1
 mov    0x200a72(%rip),%ecx        # data2
# acquire fence
 mov    0x200a64(%rip),%esi        # seq
      </code></pre>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x2004c6(%rip),%ecx        # seq
 mov    0x2004bc(%rip),%esi        # data1
 xor    %edx,%edx
 mov    0x2004af(%rip),%r8d        # data2
 lock xadd %edx,0x2004af(%rip)     # seq RdMW
      </code></pre>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x200a46(%rip),%edx        # seq
 mov    0x200a44(%rip),%eax        # data1
 mov    0x200a42(%rip),%ecx        # data2
 mfence                            # optimized RdMW!
 mov    0x200a31(%rip),%esi        # seq
      </code></pre>
    <aside class="notes"><p>x86 `lock xadd` requires exclusive access! Can optimize to `mfence; mov`.</p></aside>
  </section>
  <section>
    <h2>What's better?</h2>
    <img src="seqlock.png" />
    <aside class="notes"><p>`mfence` is 3.5× slower. On POWER RdMW is faster but doesn't scale with number of threads.</p></aside>
  </section>
</section>

<section>
  <section>
    <h2>"Normal" compiler optimizations</h2>
    <p class="fragment">Dead store elimination?</p>
    <p class="fragment">Strength reduction?</p>
    <aside class="notes">Careful: avoid doing so across synchronization points (other thread of execution can observe or modify memory, which means that the traditional optimizations have to consider more intervening instructions). DSO: can't just prove atomic store post-dominates and aliases another to eliminate the other store.</aside>
  </section>
  <section>
    <h2><code class="c++">relaxed</code> optimization</h2>
    <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x, y;
void relaxed() {
  x.fetch_add(1, std::memory_order_relaxed);
  y.fetch_add(1, std::memory_order_relaxed);
  x.fetch_add(1, std::memory_order_relaxed);
  y.fetch_add(1, std::memory_order_relaxed);
}
    </code></pre>
    <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x, y;
void relaxed() {
  x.fetch_add(2, std::memory_order_relaxed);
  y.fetch_add(2, std::memory_order_relaxed);
}
    </code></pre>
    <aside class="notes">Not aware of compilers which do this.</aside>
  </section>
  <section>
    <h2>Disabling reordering / fusing?</h2>
    <ul>
      <li class="fragment"><code class="c++">asm volatile("":::"memory");</code><code class="fragment c++"> // eek!</code></li>
      <li class="fragment"><code class="c++">std::atomic_signal_fence();</code><code class="fragment c++"> // wat?</code></li>
      <li class="fragment">Use <code class="c++">volatile</code>? <strong class="fragment">NO!</strong></li>
      <li class="fragment">Don't use <code class="c++">relaxed</code>?</li>
    </ul>
  </section>
  <section>
    <h2>Moar!</h2>
    <ul>
      <li class="fragment">Tag "non-atomic" functions, optimize around them</li>
      <li class="fragment">Interference-free regions</li>
      <li class="fragment">Optimize fence positioning</li>
      <li class="fragment">etc.</li>
    </ul>
    <aside class="notes">Compilers already know about "read-only" functions.</aside>
  </section>
</section>

<section>
  <h1><code class="c++">std::mutex</code> for sanity</h1>
  <ul>
    <li class="fragment">easier to use correctly</li>
    <li class="fragment">in theory...
      <ul>
        <li>it could still get optimized</li>
        <li>lock: <code class="c++">acquire</code>; unlock: <code class="c++">release</code></li>
      </ul>
    </li>
    <li class="fragment">pthread and kernel call makes this hard</li>
    <li class="fragment"><code class="c++">std::synchronic</code> to the rescue!</li>
  </ul>
</section>

<section>
  <h1>Sane Compilers Should Optimize Atomics</h1>
  <p>and you should use atomics</p>
  <p>Details &amp; references: <a href="https://github.com/jfbastien/no-sane-compiler">github.com/jfbastien/no-sane-compiler</a></p>
  <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
</section>

                        </div>
                </div>

                <script src="lib/js/head.min.js"></script>
                <script src="js/reveal.js"></script>

                <script>
                        // More info https://github.com/hakimel/reveal.js#configuration
                        Reveal.initialize({

                                controls: true, // Display controls in the bottom right corner
                                progress: true, // Display a presentation progress bar
                                history: true, // Push each slide change to the browser history
                                keyboard: true, // Enable keyboard shortcuts for navigation
                                overview: true, // Enable the slide overview mode
                                center: true, // Vertical centering of slides
                                touch: true,
                                loop: false,
                                rtl: false,
                                shuffle: false,
                                fragments: true, // Turns fragments on and off globally
                                help: true, // Flags if we should show a help overlay when the questionmark key is pressed
                                showNotes: false, // Flags if speaker notes should be visible to all viewers
                                autoSlide: 0,
                                autoSlideStoppable: true, // Stop auto-sliding after user input
                                autoSlideMethod: Reveal.navigateNext,
                                mouseWheel: false,
                                hideAddressBar: true,
                                previewLinks: false, // Opens links in an iframe preview overlay
                                transition: 'default', // none/fade/slide/convex/concave/zoom
                                transitionSpeed: 'default', // default/fast/slow
                                backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
                                viewDistance: 3, // Number of slides away from the current that are visible
                                parallaxBackgroundImage: 'bg.jpg',
                                parallaxBackgroundSize: '2559px 1510px', // CSS syntax, e.g. "2100px 900px"
                                // Number of pixels to move the parallax background per slide
                                // - Calculated automatically unless specified
                                // - Set to 0 to disable movement along an axis
                                parallaxBackgroundHorizontal: null,
                                parallaxBackgroundVertical: null,

                                // More info https://github.com/hakimel/reveal.js#dependencies
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                                ]
                        });
                </script>
        </body>
</html>
